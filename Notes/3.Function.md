# 3장 함수 정의와 호출

* 코틀린은 자체 컬렉션 클래스를 정의하지 않지만 자바 클래스를 확장해서 더 풍부한 API를 제공한다.

* 함수 파라미터의 디폴트 값을 정의하면 오버로딩한 함수를 정의할 필요성이 줄어든다.  
이름붙인 인자를 사용하면 함수의 인자가 많을 때 함수 호출의 가독성을 더 향상시킬 수 있다.  

* 코틀린 파일에서 클래스 멤버가 아닌 최상위 함수와 프로퍼티를 직접 선언할 수 있다. 이를 활용하면 코드 구조를 더 유연하게 만들 수 있다.

* 확장 함수와 프로퍼티를 사용하면 외부 라이브러리에 정의된 클래스를 포함해 모든 클래스의 API를 그 클래스의 소스코드를 바꿀 필요 없이 확장할 수 있다.  
확장 함수를 사용해도 실행 시점에 부가 비용이 들지 않는다.

* 중위 호출을 통해 인자가 하나 밖에 없는 메소드나 확장 함수를 더 깔끔한 구문으로 호출할 수 있다.

* 코틀린은 정규식과 일반 문자열을 처리할 때 유용한 다양한 문자열 처리 함수를 제공한다.

* 자바 문자열로 표현하려면 수많은 이스케이프가 필요한 문자열의 경우 3중 따옴표 문자열을 사용하면 더 깔끔하게 표현할 수 있다.

### Comment  
* 불행히도 자바로 작성한 코드를 호출할 때는 이름 붙인 인자를 사용할 수 없다. 따라서 안드로이드 프레임워크나 JDK가 제공하는 함수를 호출할 때도 마찬가지로 이름 붙인 인자를 쓸 수 없다. 클래스 파일에 함수 파라미터 정보를 넣는 것은 자바 8 이후 추가된 선택적 특징인데, 코틀린은 JDK 6와 호환된다.

* @JvmOverload 애노테이션을 함수에 추가하면 코틀린 컴파일러가 자동으로 맨 마지막 파라미터를 하나씩 생략한 오버로딩한 자바 메소드에 추가한다.

* 최상위 함수가 포함되는 클래스의 이름을 변경하고 싶다면 @JvmName 애노테이션을 파일의 맨 앞, 패키지 이름 선언 이전에 위치시키면 된다. 

* 기본적으로 최상위 프로퍼티도 게터, 세터가 만들어져 사용된다.  
상수처럼 사용하려면 const 변경자를 추가하면 된다. 그러면 프로퍼티를 public static final 필드로 컴파일하게 만들 수 있다. 단, 원시타입과 String 타입의 프로퍼티만 const 지정이 가능하다. 

* 확장 함수 안에서는 클래스 내부에서만 사용할 수 있는 비공개(private) 멤버나 보호된(protected) 멤버를 사용할 수 없다.

* 확장 함수를 사용하기 위해서는 임포트해야만 한다. as 키워드를 사요아면 임포트한 클래스나 함수를 다른 이름으로 부를 수 있다. 이름을 바꿔 임포트하면 이름 충돌을 막을 수 있다.  
코틀린 문법상 확장 함수는 반드시 짧은 이름을 써야 한다. 

* 확장 함수는 단지 정적 메소드 호출에 대한 문법적인 편의(syntatic sugar)일 뿐이다.  
확장 함수가 정적 메소드와 같은 특징을 가지므로, 확장 함수를 하위 클래스에서 오버라이드할 수 없다.

* 확장 프로퍼티는 아무 상태도 가질 수 없다.  
뒷받침하는 필드가 없어서 기본 게터 구현을 제공할 수 없으므로 최소한 게터는 꼭 정의를 해야 한다. 또한 담을 장소가 없으므로 초기화 코드도 쓸 수 없다.

* 