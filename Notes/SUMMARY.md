# 코틀린이란 무엇이며, 왜 필요한가?

## 코틀린은 무엇인가?
코틀린은 자바 플랫폼에서 돌아가는 새로운 프로그래밍 언어다.  

코틀린은 간결하고 실용적이며, 자바 코드와의 상호운용성(interoperability)을 중시한다.  

코틀린은 기존 자바 라이브러리나 프레임워크와 함께 잘 작동하며, 성능도 자바와 같은 수준이다.  

#### 정적 타입 지정 언어
자바와 마찬가지로 코틀린도 정적 타입(statically typed) 지정 언어다.  
  
정적 타입 지정이라는 말은 모든 프로그램 구성 요소의 타입을 컴파일 시점에 알 수 있고 프로그램 안에서 객체의 필드(field)나 메소드(method)를 사용할 때마다 컴파일러가 타입을 검증해준다는 뜻이다.  

자바와 달리 코틀린에서는 모든 변수의 타입을 프로그래머가 직접 명시하지 않아도 대부분의 경우 코틀린 컴파일러가 문맥으로부터 변수 타입을 자동으로 유추할 수 있기 때문에 타입 선언을 생략해도 된다. 이런 기능을 타입 추론(type inference)이라고 부른다.

장점
- 성능  
실행 시점에 어떤 메소드를 호출할 지 알아내는 과정이 필요 없으므로 메소드 호출이 더 빠르다.

- 신뢰성  
컴파일러가 프로그램의 정확성(correctness)을 검증하기 때문에 실행 시 프로그램이 오류로 중단될 가능성이 더 적어진다.
- 유지 보수성  
코드에서 다루는 객체가 어떤 타입에 속하는지 알 수 있기 때문에 처음 보는 코드를 다룰 때도 더 쉽다.
- 도구 지원  
정적 타입 지정을 활용하면 더 안전하게 리팩토링(refactoring)할 수 있고, 도구는 더 정확한 코드 완성 기능을 제공할 수 있으며, IDE의 다른 지원 기능도 더 잘 만들 수 있다.

### 함수형 프로그래밍
함수형 프로그래밍의 핵심 개념
- 일급 시민인(first-class) 함수  
함수(프로그램의 행동을 나타내는 코드 조각)를 일반 값처럼 다룰 수 있다. 변수에 저장하고, 인자로 다른 함수에 전달할 수 있으며, 함수에서 새로운 함수를 만들어서 반환할 수 있다.

- 불변성(immutability)  
함수형 프로그래밍에서는 일단 만들어지고 나면 내부 상태가 절대로 바뀌지 않는 불변 객체를 사용해 프로그램을 작성한다.

- 부수 효과(side-effect) 없음  
입력이 같으면 항상 같은 출력을 내놓고 다른 객체의 상태를 변경하지 않으며, 함수 외부나 다른 바깥 환경과 상호작용하지 않는 순수 함수(pure function)를 사용한다.

### 코틀린의 철학
#### 실용성
코틀린은 실제 문제를 해결하기 위해 만들어진 실용적인 언어다.  

코틀린은 어느 특정 프로그래밍 스타일이나 패러다임을 사용할 것을 강제로 요구하지 않는다.  

실용성에 있어 코틀린의 다른 측면은 도구를 강조한다는 점이다. 좋은 언어만큼이나 편리한 개발 환경도 생산성 향상에 필수적이다.

#### 간결성
코드가 더 간단하고 간결할수록 내용을 파악하기가 더 쉽다.  

코틀린을 만들면서 프로그래머가 작성하는 코드에서 의미가 없는 부분을 줄이고, 언어가 요구하는 구조를 만족시키기 위해 별 뜻은 없지만 프로그램에 꼭 넣어야 하는 부수적인 요소를 줄이기 위해 많은 노력을 기울였다.  

#### 안전성
JVM에서 실행되는 정적 타입 지정 언어로서 코틀린은 애플리케이션의 타입 안전성을 보장한다.

대부분의 경우 코틀린 컴파일러가 타입을 자동으로 추론해주기 때문에 여러분이 직접 타입 정보를 지정할 필요가 없다. 한걸음 더 나아가 컴파일 시점 검사를 통해 오류를 더 많이 방지해준다. 가장 중요한 내용으로 코틀린은 프로그램의 NullPointerException을 없애기 위해 노력한다.

코틀린이 방지해주는 다른 예외로는 ClassCastException이 있다. 어떤 객체를 다른 타입으로 캐스트(cast)하기 전에 타입을 미리 검사하지 않으면 ClassCastException이 발생할 수도 있다.

#### 상호운용성
상호운용성과 관련해 자바 프로그래머들이 던지는 첫 번째 질문은 아마도 "기존 라이브러리를 그대로 사용할 수 있느냐?"일 것이다. 코틀린의 경우 그에 대한 답은 "물론 그렇다"이다.

라이브러리가 어떤 API를 제공하던 간에 코틀린에서 그 API를 활용할 수 있다. 자바 메소드를 호출하거나 자바 클래스를 상속(inherit) 확장(extend)하거나 인터페이스(interface)를 구현(implement)하거나 자바 애노테이션을 코틀린 코드에 적용하는 등의 일이 모두 가능하다.  


#### 코틀린 코드 컴파일
코틀린 컴파일러로 컴파일한 코드는 코틀린 런타임 라이브러리(kotlin runtime library)에 의존한다. 

런타임 라이브러리에는 코틀린 자체 표준 라이브러리 클래스와 코틀린에서 자바 API의 긴으을 확장한 내용이 들어있다. 코틀린으로 컴파일한 애플리케이션을 배포할 때는 런타임 라이브러리도 함께 배포해야 한다.

---

# 코틀린 기초
- 함수, 변수, 클래스, enum, 프로퍼티를 선언하는 방법
- 제어 구조
- 스마트 캐스트
- 예외 던지기와 예외 잡기

## 함수와 변수
- 함수를 선언할 때 fun 키워드를 사용한다.

- 파라미터 이름 뒤에 그 파라미터의 타입을 쓴다.

- 함수를 최상위 수준에 정의할 수 있다. 꼭 클래스 안에 함수를 넣어야 할 필요가 없다.

- 배열도 일반적인 클래스와 마찬가지다. 코틀린에는 자바와 달리 배열 처리를 위한 문법이 따로 존재하지 않는다.

- System.out.println 대신에 println 이라고 쓴다. 코틀린 표준 라이브러리는 여러 가지 표준 자바 라이브러리 함수를 간결하게 사용할 수 있게 감싼 래퍼(wrapper)를 제공한다. 

- 최신 프로그래밍 언어 경향과 마찬가지로 줄 끝에 세미콜론(;)을 붙이지 않아도 좋다.

#### 문(statement)과 식(expression)의 구분
식은 값을 만들어 내며 다른 식의 하위 요소로 계산에 참여할 수 있는 반면 문은 자신을 둘러싸고 있는 가장 안쪽 블록의 최상위 요소로 존재하며 아무런 값을 만들어내지 않는다는 차이가 있다.

자바에서는 모든 제어 구조가 문인 반면 코틀린에서는 루프를 제외한 대부분의 제어 구조가 식이다. 

if는 문이 아니라 식이다. 반면 대입분은 자바에서는 식이었으나 코틀린에서는 문이 됐다.

#### 식이 본문인 함수
```kotlin
fun max(a: Int, b: Int) = if (a > b) a else b
```
코틀린에서는 식이 본문인 함수가 자주 쓰인다. 여기서 반환 타입을 생략할 수 있는 이유는 무엇일까?  

식이 본문인 함수의 경우 굳이 사용자가 반환 타입을 적지 않아도 컴파일러가 함수 본문 식을 해석해서 식의 결과 타입을 함수 변환 타입으로 정해준다.

이렇게 컴파일러가 타입을 분석해 프로그래머 대신 프로그램 구성 요소의 타입을 정해주는 기능을 타입 추론(type inference)이라 부른다.

블록이 본문인 함수가 값을 반환한다면 반드시 return문을 사용해 반환 값을 명시해야 한다.

#### 변수
코틀린에서는 타입 지정을 생략하는 경우가 흔하다.
```kotlin
val question = "삶, 우주, 그리고 모든 것에 대한 궁극적인 질문"
val answer = 42 // val answer: Int = 42
val yearsToCompute = 7.5e6 // 부동 소수점을 사용한다면 변수 타입은 Double이 된다. 
```
타입을 지정하지 않으면 컴파일러가 초기화 식을 분서갷서 초기화 식의 타입을 변수 타입으로 지정한다.

초기화 식이 없다면 타입을 지정해야 한다.

##### 변경 가능한 변수와 변경 불가능한 변수
- val (값을 뜻하는 value) - 변경 불가능한(immutable) 참조를 저장하는 변수다.  
val로 선언된 변수는 일단 초기화하고 나면 재 대입이 불가능하다. 자바로 말하자면 final 변수에 해당한다.

- var (변수를 뜻하는 variable) - 변경 가능한(mutable) 참조다.  
이런 변수의 값은 바뀔 수 있다. 자바의 일반 변수에 해당한다.

기본적으로 모든 변수를 val 키워드를 사용해 불변 변수로 선언하고, 나중에 꼭 필요할 때만 var로 변경하라.

val 변수는 블록을 실행할 때 정확히 한 번만 초기화돼야 한다.
```kotlin
val message: String
if (canPerformOperation()) {
    message = "Success"
} else {
    message = "Failed"
}
```

val 참조 자체는 불변일지라도 그 참조가 가리키는 객체의 내부 값은 변경될 수 있다는 사실을 기억하라. 
```kotlin
val language = arrayListOf("Java")
language.add("Kotlin")
```

var 키워드를 사용하면 변수의 값을 변경할 수 있지만 변수의 타입은 고정돼 바뀌지 않는다.
```kotlin
var answer = 42
answer = "no answer" // Error: type mismatch 컴파일 오류 발생
```
타입(String)이 컴파일러가 기대하는 타입(Int)과 다르기 때문에 컴파일 오류가 발생한다. 변수 선언 이후 변수 재대입이 이뤄질 때는 이미 추론한 변수의 타입을 염두에 두고 대입문의 타입을 검사한다.

#### 더 쉽게 문자열 형식 지정: 문자열 템플릿
```kotlin
val name = "Kotlin"
println("Hello $name!")
```
문자열 템플릿(string template)이라는 기능을 보여준다. 문자열 리터럴의 필요한 곳에 변수를 넣되 변수 앞에 $를 추가해야 한다.

문자열 템플릿 안에는 복잡한 식도 중괄호로 둘러싸서 문자열 템플릿 안에 넣을 수 있다.
```kotlin
if (args.size > 0) {
    println("Hello, ${args[0]}!")
}
```

## 클래스와 프로퍼티
```java
public class Person {
    private final String name;
    
    public Person(String name) {
        this.name = name;
    }
    
    public String getName() {
        return name;
    }
}
```
자바에서는 생성자 본문에 이 같은 코드가 반복적으로 들어가는 경우가 많다. 코틀린에서는 필드 대입 로직을 훨씬 더 적은 코드로 작성할 수 있다.
```kotlin
class Person(val name: String)
```
이런 유형의 클래스(코드가 없이 데이터만 저장하는 클래스)를 값 객체(value obejct)라 부르며, 다양한 언어가 값 객체를 간결하게 기술할 수 있는 구문을 제공한다.

자바를 코틀린으로 변환한 결과, public 가시성 변경자(vibility modifier)가 사라졌음을 확인하라. 코틀린의 기본 가시성은 public이므로 이런 경우 생략해도 된다.

#### 프로퍼티
클래스라는 개념의 목적은 데이터를 캡슐화(encapsulate)하고 캡슐화한 데이터를 다루는 코드를 한 주체 아래 가두는 것이다.  

자바에서는 필드와 접근자를 한데 묶어 프로퍼티(property)라고 부르며, 코틀린은 프로퍼티를 언어 기본 기능으로 제공하며, 코틀린 프로퍼티는 자바의 필드와 접근자 메소드를 완전히 대신한다.

```kotlin
class Person (
    val name: String,   // 읽기 전용 프로퍼티, (비공개)필드와 (공개)게터를 만들어낸다.
    val isMarried: Boolean  // 쓸 수 있는 프로퍼티, (비공개)필드와 (공개)게터, (공개)세터를 만들어 낸다.
)
``` 
기본적으로 코틀린에서 프로퍼티를 선언하는 방식은 프로퍼티와 관련 있는 접근자를 선언하는 것이다.
```kotlin
val person = Person("Bob", true)    // new 키워드를 사용하지 않고 생성자를 호출
println(person.name)    // 프로퍼티 이름을 직접 사용해도 코틀린이 자동으로 게터를 호출해준다. person.getName()
person.isMarried = false
```
게터를 호출하는 대신 프로퍼티를 직접 사용했음에 유의하라. 변경가능한 프로퍼티의 세터도 마찬가지 방식으로 동작한다.

대부분의 프로퍼티에는 그 프로퍼티의 값을 저장하기 위한 필드가 있다. 이를 프로퍼티를 뒷받침하는 필드(backing field)라고 부른다.  

#### 커스텀 접근자
```kotlin
class Rectangle(val height: Int, val width: Int) {
    val isSquare: Boolean
        get() {     // 프로퍼티 게터 선언
            return height == width
        }
}
```
isSquare 프로퍼티에는 자체 값을 저장하는 필드가 필요 없다. 이 프로퍼티에는 자체 구현을 제공하는 게터만 존재한다.

파라미터가 없는 함수와 게터를 정의하는 방식 중 어느 쪽이 더 나은지 궁금한 독자도 있을 것이다. 두 방식 모두 비슷하다. 구현이나 성능상 차이는 없다. 차이가 나는 부분은 가독성 뿐이다.

일반적으로 클래스의 특성(프로퍼티에는 특성이라는 뜻이 있다.)을 정의하고 싶다면 프로퍼티로 그 특성을 정의해야 한다.

#### 디렉터리와 패키지
모든 코틀린 파일의 맨 앞에 package문을 넣을 수 있다. 그러면 그 파일 안에 있는 모든 선언(클래스, 함수, 프로퍼티 등)이 해당 패키지로 들어간다.  

같은 패키지에 속해 있다면 다른 파일에서 정의한 선언일지라도 직접 사용할 수 있다. 반면 다른 패키지에 정의한 선언을 사용하려면 임포트를 통해 선언을 불러와야 한다.

코틀린에서는 클래스 임포트와 함수 임포트에 차이가 없으며, 모든 선언을 import 키워드로 가져올 수 있다. 최상위 함수는 그 이름을 써서 임포트할 수 있다.

패키지 이름 뒤에 .*를 추가하면 패키지 안의 모든 선언을 임포트할 수 있다. 이런 스타 임포트(star import)를 사용하면 패키지 안에 있는 모든 클래스뿐 아니라 최상위에 정의된 함수나 프로퍼티까지 모두 불러온다는 점에 유의하라.

코틀린에서는 여러 클래스를 한 파일에 넣을 수 있고, 파일의 이름도 마음대로 정할 수 있다. 코틀린에서는 디스크상의 어느 디렉터리에 소스코드 파일을 위치시키든 관계없다. 따라서 원하는 대로 소스코드를 구성할 수 있다.

자바와 코틀린을 함께 사용하는 프로젝트에서는 자바의 방식을 따르는게 중요하다. 자바의 방식을 따르지 않으면 자바 클래스를 코틀린 클래스로 마이그레이션할 때 문제가 생길 수도 있다.

## enum 과 when
```kotlin
enum class Color {
    RED, ORANGE, YELLOW, GREEN, BLUE, INDIGO, VIOLET
}
```
자바에서는 enum을 사용하지만 코틀린에서는 enum class를 사용한다. enum은 소프트 키워드로 class 앞에 있을 때는 특별한 의미를 지니지만 다른 곳에서는 이름에 사용할 수 있다.

enum은 단순한 값만 열거하는게 아니라 프로퍼티나 메소드를 정의할 수 있다.
```kotlin
enum class Color (
    val r: Int, val g: Int, val b: Int
) {
    RED(255, 0, 0), ORANGE(255, 165, 0),
    YELLOW(255, 2525, 0), GREEN(0, 255, 0), BLUE(0, 0, 255),
    INDIGO(75, 0, 130), VIOLET(238, 139, 238);
    
    fun rgb() = (r * 256 + g) * 256 + b
 
}
```
enum에서도 일반적인 클래스와 마찬가지로 생성자와 프로퍼티를 선언한다.

이 예제에서는 코틀린에서 유일하게 세미콜론(;)이 필수인 부분을 볼 수 있다. enum 클래스 안에 메소드를 정의하는 경우 반드시 enum 상수 목록과 메소드 정의 사이에 세미콜론을 넣어야 한다.

#### when으로 enum 클래스 다루기
if와 마찬가지로 when도 값을 만들어내는 식이다.
```kotlin
import Color.*

fun getMnemonic(color: Color) = when(color) {
    RED, ORANGE, YELLOW -> "warm"
    GREEN -> "neutral"
    BLUE, INDIGO, BIOLET -> "cold"
}
```
- 자바와 달리 각 분기의 끝에 braek를 넣지 않아도 된다. 성공적으로 매치되는 분기를 찾으면 분기를 실행한다.
 
- 한 분기 안에 여러 값을 매치 패턴으로 사용할 수도 있다. 그럴 경우 값 사이를 콤마(,)로 분리한다.

- 상수 값을 임포트하면 코드를 더 간단하게 만들 수 있다.

코틀린에서 when은 자바의 switch보다 더 강력하다. 분기 조건에 상수만을 사용할 수 있는 자바와 달리 코틀린은 임의의 객체를 허용한다.
```kotlin
fun mix(c1: Color, c2: Color) = 
    when (setOf(c1, c2)) {
        setOf(RED, YELLOW) -> ORAGNE
        setOf(YELLOW, BLUE) -> GREEN
        setOf(BLUE, VIOLET) -> INDIGO
        else -> throw Exception("Dirty color")        
    }
```
코틀린 표준 라이브러리에는 인자로 전달받은 여러 객체를 그 객체들을 포함하는 집합인 Set 객체로 만드는 setOf라는 함수가 있다. 

집합(set)은 원소가 모여 있는 컬렉션으로, 각 원소의 순서는 중요하지 않다. 여기서는 setOf(c1, c2)와 분기 조건에 있는 객체 사이를 매치할 때 동등성(equility)을 사용한다.

when의 분기 조건 부분에 식을 넣을 수 있기 때문에 많은 경우 코드를 더 간결하고 아름답게 작성할 수 있다.

#### 인자 없는 when 사용
위의 코드가 비효율적임을 눈치 챈 사람도 있을 것이다. 함수가 호출될 때마다 함수 인자로 주어진 두 색이 when의 분기 조건에 있는 다른 두 색과 같은지 비교하기 위해 여러 Set 인스턴스를 생성한다.

이 함수가 아주 자주 호출된다면 불필요한 가비지 객체가 늘어나는 것을 방지하기 위해 함수를 고쳐 쓰는 편이 낫다.
```kotlin
fun mixOptimized(c1: Color, c2: Color) = 
    when {
        (c1 == RED && c2 == YELLOW) ||
        (c1 == YELLOW && c2 == RED) -> 
            ORANGE
        
        (c1 == YELLOW && c2 == BLUE) ||
        (c1 == BLUE && c2 == YELLOW) -> 
            GREEN

        (c1 == BLUE && c2 == VIOLET) ||
        (c1 == VIOLET && c2 == BLUE) -> 
            INDIGO
        
        else -> throw Exception("Dirty color")
    }   
```
mixOptimized는 추가 객체를 만들지 않는다는 장점이 있지만 가독성이 떨어진다.

#### 스마트 캐스트 : 타입 검사와 타입 캐스트를 조합
(1 + 2) + 4 와 같은 간단한 산술식을 계산하는 함수를 만들어 보자.
```kotlin
interface Expr // 여러 타입의 식 객체를 아우르는 공통 타입의 역할만 수행
class Num(val value: Int) : Expr // value 프로퍼티만 존재하는 단순한 클래스로 Expr 인터페이스를 구현한다.
class Sum(val left: Expr, val right: Expr): Expr // Expr 타입의 객체라면 어떤 것이나 Sum의 인자가 될 수 있다. 
```
Expr 인터페이스에는 두 가지 구현 클래스가 존재한다. 따라서 식을 평가하려며 두 가지 경우를 고려해야 한다.
- 어던 식이 수라면 그 값을 반환한다.
- 어떤 식이 합계라면 좌항과 우항의 값을 계산한 다음에 그 두 값을 합한 값을 반환한다.
```kotlin
fun eval(e: Expr): Int {
    if (e is Num) {
        val n = e as Num
        return n.value
    }
    if (e is Sum) {
        return eval(e.left) + eval(e.right) // 변수 e에 대해  스마트 캐스트를 사용한다.
    }
}
```
코틀린에서는 is를 사용해 변수 타입을 검사한다. is 검사는 자바의 instanceof 와 비슷하지만 다르다. instanceof는 확인 후 명시적으로 변수 타입을 캐스팅한다. 하지만 코틀린에서는 프로그래머 대신 컴파일러가 캐스팅해준다.

어떤 변수가 원하는 타입인지 is로 검사하고 나면 굳이 변수를 원하는 타입으로 캐스팅하지 않아도 마치 처음부터 그 변수가 원하는 타입으로 선언된 것처럼 사용할 수 있다.

IDE를 사용하면 스마트 캐스트 부분의 배경색을 달리 표시해주므로 이런 변환이 자동으로 이뤄졌음을 쉽게 알 수 있다.

스마트 캐스트는 is로 변수에 든 값의 타입을 검사한 다음에 그 값이 바뀔 수 없는 경우에만 작동한다. 

원하는 타입으로 명시적으로 타입 캐스팅하려면 as 키워드를 사용한다.
```kotlin
val n = e as Num
```

## while과 for 루프
코틀린 특성 중 자바와 가장 비슷한 것이 이터레이션이다. 코틀린의 while 루프는 자바와 동일하다.

코틀린에는 자바의 for 루프에 해당하는 요소가 없다. 코틀린에서는 범위(range)를 사용한다.

범위는 기본적으로 두 값으로 이뤄진 구간이다. 보통은 그 두 값은 정수 등의 숫자 타입의 값이며 .. 연산자로 시작 값과 끝 값을 연결해서 범위를 만든다.

코틀린의 범위는 폐구간 또는 양끝을 포함하는 구간이다. 이는 두 번째 값이 항상 범위에 포함된다는 뜻이다.

어떤 범위에 속한 값을 일정한 순서로 이터레이션하는 경우를 수열(progression)이라고 부른다.
```kotlin
for (i in 100 downTo 1 step 2) {
    println(i)
}
```
증가 값 step을 갖는 수열에 대해 이터레이션 한다. 증가 값을 사용하면 수를 건너 뛸 수 있다.

끝 값을 포함하지 않는 반만 닫힌 범위에 대해 이터레이션하면 편할 때에는 until 함수를 사용한다. for (x in 0 until size)

#### in으로 컬렉션이나 범위의 원소 검사
in 연산자를 사용해 어떤 값이 범위에 속하는지 검사할 수 있다. 반대로 !in을 사용하면 어떤 값이 범위에 속하지 않는지 검사할 수 있다.
```kotlin
fun isLetter(c: Char) = c in 'a'..'z' || c in 'A'..'Z'
fun isNotDigit(c: Char) = c !in '0'..'9'
```
범위는 문자에만 국한되지 않는다. 비교가 가능한 클래스라면(java.lang.Comparable 인터페이스를 구현한 클래스라면) 그 클래스의 인스턴스 객체를 사용해 범위를 만들 수 있다.
```kotlin
println("Kotlin" in "Java".."Scala")
```

#### 코틀린의 예외 처리
자바와 마찬가지로 예외를 처리하려면 try와 catch, finally 절을 함께 사용한다.
```kotlin
fun readNumber(reader: BufferedReader): Int? {
    try {
        val line = reader.readLine()
        return Integer.parseInt(line)
    } catch (e: NumberFormatException) {
        return null
    } finally {
        reader.close()
    }
}
```
자바 코드와 가장 큰 차이는 throws(이 경우 s가 붙어있다)절이 코드에 없다는 점이다. 

자바에서는 함수를 작성할 때 함수 선언 뒤에 throws IOException을 붙여야 한다. 이유는 IOException이 체크 예외(checked exception)이기 때문이다.

자바에서는 체크 예외를 명시적으로 처리해야 한다. 어떤 함수가 던질 가능성이 있는 예외나 그 함수가 호출한 다른 함수에서 발생할 수 있는 예외를 모두 catch로 처리해야 하며, 처리하지 않은 예외는 throws 절에 명시해야 한다.

코틀린에서는 함수가 던지는 예외를 지정하지 않고 발생한 예외를 잡아내도 되고 잡아내지 않아도 된다. 

코틀린의 try 키워드는 if내 when과 마찬가지로 식이다. try 코드 블록의 실행이 정상적으로 끝나면 그 블록의 마지막 식의 값이 결과가 된다.