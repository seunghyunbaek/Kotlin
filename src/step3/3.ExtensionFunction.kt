package step3

import strings.lastChar

// joinToString을 좀 더 개선할 방법을 살펴보자

// 기존 코드와 코틀린 코드를 자연스럽게 통합하는 것은 코틀린의 핵심 목표 중 하나다.
// 완전히 코틀린으로만 이뤄진 프로젝트조차도 JDK나 안드로이드 프레임워크 또는 다른 서드파티 프레임워크 등의 자바 라이브러리를 기반으로 만들어진다.
// 또 코틀린을 기존 자바 프로젝트에 통합하는 경우에는 코틀린으로 직접 변환할 수 없거나 미처 변환하지 않은 기존 자바 코드를 처리할 수 있어야 한다.
// 이런 기존 자바 API를 재작성하지 않고도 코틀린이 제공하는 여러 편리한 기능을 사용할 수 있다면 정말 좋은 일 아닐까?
// 바로 확장 함수(extension function)가 그런 역할을 해줄 수 있다.

// 개념적으로 확장 함수는 단순하다.
// 확장 함수는 어떤 클래스의 멤버 메소드인 것처럼 호출할 수 있지만 그 클래스의 밖에 선언된 함수다.
// 확장 함수를 보여주기 위해 어떤 문자열의 마지막 문자를 돌려주는 메소드를 추가해보자.(join.kt 24줄)

// 어떤 면에서 이는 String 클래스에 새로운 메소드를 추가하는 것과 같다.
// String 클래스가 여러분이 직접 작성한 코드가 아니고 심지어 String 클래스의 소스코드를 소유한 것도 아니지만, 여러분은 여전히 원하는 메소드를 String 클래스에 추가할 수 있다.
// 심지어 String이 자바나 코틀린 등의 언어 중 어떤 것으로 작성됐는가는 중요하지 않다.
// 자바 클래스로 컴파일한 클래스 파일이 있는 한 그 클래스에 원하는 대로 확장을 할 수 있다.(join.kt 31줄)
// 이제부터는 클래스의 멤버 메소드와 확장 함수를 모두 메소드라고 부를 것이다.
// 예를 들어 "확장 함수 내부에서는 수신 객체의 모든 메소드를 호출할 수 있다"라고 말하면 확장 함수 내부에서 수신 객체의 멤버 메소드와 확장 함수를 모두 호출할 수 있다는 뜻이다.
// 호출하는 쪽에서는 확장 함수와 멤버 메소드를 구분할 수 없다. 그리고 확장 함수인지 멤버 메소드인지 중요한 경우도 없다.
fun main(args: Array<String>) {
    println("kotlin".lastChar()) // String이 수신 객체 타입이고 "kotlin"이 수신 객체다.
}