package step2
import java.util.Random
import step1.Person

// 모든 코틀린 파일의 맨 앞에 package문을 넣을 수 있다.
// 그러면 그 파일 안에 있는 모든 선언(클래스, 함수, 프로퍼티 등)이 해당 패키지에 들어간다.
// 같은 패키지에 속해 있다면 다른 파일에서 정의한 선언일지라도 직접 사용할 수 있다.
// 반면 다른 패키지에 정의한 선언을 사용하려면 임포트를 통해 선언을 불러와야 한다.
// 임포트문은 파일의 맨 앞에 와야 하며 import 키워드를 사용한다.
// 패키지 이름뒤에 .*를 추가하면 패키지안의 모든 선언을 임포트할 수 있다.

fun createRandomRectangle(): Rectangle { // Rectangle은 같은 패키지의 4.Class.kt에 정의되어 있으므로 직접 사용할 수 있다.
    val random = Random()
    return Rectangle(random.nextInt(), random.nextInt())
}

fun main(args: Array<String>) {
    println(createRandomRectangle().isSquare)
    println(Person("Bob", age=24)) // 이름과 나이를 갖는 Person 클래스는 step1 패키지 0.Kotlin.kt 파일에 있다.
}

// 자바에서는 패키지의 구조와 일치하는 디렉터리 계층 구조를 만들고 클래스의 소스코드를 그 클래스가 속한 패키지와 같은 디렉터리에 위치시켜야 한다.
// 코틀린에서는 여러 클래스를 한 파일에 넣을 수 있고, 파일의 이름도 마음대로 정할 수 있으며, 디스크상의 어느 디렉터리에 소스코드 파일을 위치시키든 관계없다.
// 하지만 대부분의 경우 자바와 같이 패키지별로 디렉터리를 구성하는 편이 낫다.
// 특히 자바와 코틀린을 함께 사용하는 프로젝트에서는 자바의 방식을 따르지 않으면 자바 클래스를 코틀린 클래스로 마이그레이션할 때 문제가 생길 수도 있다.
// 하지만 여러 클래스를 한 파일에 넣는 것을 주저해서는 안된다. 특히 각 클래스를 정의하는 소스코드 크기가 아주 작은 경우 더욱 그렇다(코틀린에서는 클래스 소스코드 크기가 작은 경우가 자주 있다.).