package step4

// 뻔하지 않은 생성자와 프로퍼티를 갖는 클래스 선언

// 자바에서는 생성자를 하나 이상 선언할 수 있다.
// 코틀린도 비슷하지만 한 가지 바뀐 부분이 있다.
// 코틀린은 주(primary) 생성자(보통 주 생성자는 클래스를 초기화할 때 주로 사용하는 간략한 생성자로, 클래스 본문 밖에서 정의한다)와 부(secondary) 생성자(클래스 본문 안에서 정의한다)를 구분한다.
// 또한 코틀린에서는 초기화 블록(initializer block)을 통해 초기화 로직을 추가할 수 있다.

// 먼저 주 생성자와 초기화 블록을 선언하는 문법을 살펴보자.
// step2에서 간단히 클래스 선언을 하는 방법을 살펴봤다.
/* class User(val nickname: String) */
// 보통 클래스의 모든 선언은 중괄호({}) 사이에 들어간다. 하지만 이 클래스 선언에는 중괄호가 없고 괄호 사이에 val 선언만 존재한다. 그 이유가 궁금할 것이다.
// 이렇게 클래스 이름뒤에 오는 괄호로 둘러싸인 코드를 주 생성자(primary constructor)라고 부른다.
// 주 생성자는 생성자 파라미터를 지정하고 그 생성자 파라미터에 의해 초기화되는 프로퍼티를 정의하는 두 가지 목적에 쓰인다.
// 이제 이 선언을 같은 목적을 달성할 수 있는 가장 명시적인 선언으로 풀어서 실제로는 어떤 일이 벌어지는지 살펴보자.
/*
class User constructor(_nickname: String) { // 파라미터가 하나만 있는 주 생성자 생성
    val nickname:String // 프로퍼티 선언

    init { // 초기화 블록
        nickname = _nickname
    }
}
*/
// 이 예제에서 constructor나 init이라는 새로운 키워드를 볼 수 있다.
// constructor 키워드는 주 생성자나 부 생성자 정의를 시작할 때 사용한다.
// init 키워드는 초기화 블록을 시작한다. 초기화 블록에는 클래스의 객체가 만들어질 때(인스턴스화될때) 실행될 초기화 코드가 들어간다. 초기화 블록은 주 생성자와 함께 사용된다.
// 주 생성자는 제한적이기 때문에 별도의 코드를 포함할 수 없으므로 초기화 블록이 필요하다. 필요하다면 클래스 안에 여러 초기화 블록을 선언할 수 있다.
// 생성자 파라미터 _nickname에서 맨 앞의 밑줄(_)은 프로퍼티와 생성자 파라미터를 구분해준다. 다른 방법으로 자바에서 흔히 쓰는 방식처럼 this.nickname = nickname 같은 식으로 생성자 파라미터와 프로퍼티의 이름을 같게하고 프로퍼티에 this를 써서 모호성을 없애도 된다.

// 이 예제에서는 nickname 프로퍼티를 초기화하는 코드를 nickname 프로퍼티 선언에 포함시킬 수 있어 초기화 블록을 넣을 필요가 없다.
// 또 주 생성자앞에 별다른 어노테이션이나 가시성 변경자가 없다면 constructor를 생략해도 된다.
/*
class User(_nickname: String) { // 파라미터가 하나뿐인 주 생성자
    val nickname = _nickname // 프로퍼티를 주 생성자의 파라미터로 초기화한다.
}
*/
// 이 예제는 같은 클래스를 정의하는 여러 방법 중 하나다.
// ☆ 프로퍼티를 초기화하는 식이나 초기화 블록 안에서만 주 생성자의 파라미터를 참조할 수 있다는 점에 유의하라.
// 방금 살펴본 두 예제는 클래스 본문에서 val 키워드를 통해 프로퍼티를 정의했다. 하지만 주 생성자의 파라미터로 프로퍼티를 초기화한다면 그 주 생성자 파라미터 이름앞에 val을 추가하는 방식으로 프로퍼티 정의와 초기화를 간략히 쓸 수 있다.
/*
class User(val nickname: String) // "val"은 이 파라미터에 상응하는 프로퍼티가 생성된다는 뜻이다.
*/
// 지금까지 살펴본 세 가지 User 선언은 모두 같다. 하지만 마지막 선언이 가장 간결하다. 함수 파라미터와 마찬가지로 생성자 파라미터에도 디폴트 값을 정의할 수 있다.
open class User(val nickname: String,
           val isSubscribed: Boolean = true)

fun main(args: Array<String>) {
    val hyun = User("현석")
    println(hyun.isSubscribed)

    val gye = User("계영", false) // 모든 인자를 파라미터 선언 순서대로 지정할 수 있다.
    println(gye.isSubscribed)

    val hey = User("혜원", isSubscribed = false) // 생성자 인자 중 일부에 대해 이름을 지정할 수도 있다.
    println(hey.isSubscribed)

    val seung = User(isSubscribed = false, nickname = "승현") // 이름을 지정하여 인자를 넣으면 순서를 다르게 지정할 수도 있다.
    println(seung.isSubscribed)

    val rtobit = RtoBit()
    println(rtobit.up) // false
}

// 노트
// 모든 파라미터에 디폴트 값을 지정할 경우 컴파일러가 자동으로 파라미터가 없는 생성자를 만들어준다. 그렇게 자동으로 만들어진 파라미터 없는 생성자는 디폴트 값을 사용해 클래스를 초기화 한다.
// 의존관계 주임(DI, Dependency Injection) 프레임워크 등 자바 라이브러리 중에는 파라미터가 없는 생성자를 통해 객체를 생성해야만 라이브러리 사용이 가능한 경우가 있는데, 코틀린이 제공하는 파라미터 없는 생성자는 그런 라이브러리와의 통합을 쉽게 해준다.
class RtoBit(val up: Boolean = false,
             val down: Boolean = false,
             val left: Boolean = false,
             val right: Boolean = false)

// 클래스에 기반 클래스가 있다면 주 생성자에서 기반 클래스의 생성자를 호출해야할 필요가 있다. 기반 클래스를 초기화하려면 기반 클래스 이름 뒤에 괄호를 치고 생성자 인자를 넘긴다.
class TwitterUser(nickname: String): User(nickname) {}

// 클래스를 정의할 때 별도로 생성자를 정의하지 않으면 컴파일러가 자동으로 아무 일도 하지 않는 인자가 없는 디폴트 생성자를 만들어준다.
open class Button3 // 인자가 없는 디폴트 생성자가 만들어진다.
class RadioButton: Button3() {} // Button3의 생성자는 아무 인자도 받지 않지만, Button3 클래스를 상속한 하위 클래스는 반드시 Button3 클래스의 생성자를 호출해야 한다.
// 이 규칙으로 인해 기반 클래스의 이름 뒤에는 꼭 빈 괄호가 들어간다(물론 생성자 인자가 있다면 괄호 안에 인자가 들어간다).
// 인터페이스는 생성자가 없기 때문에 어떤 클래스가 인터페이스를 구현하는 경우 그 클래스의 상위 클래스 목록에 있는 인터페이스 이름 뒤에는 아무 괄호도 없다.

// 어떤 클래스를 클래스 외부에서 인스턴스화하지 못하게 막고 싶다면 모든 생성자를 private으로 만들면 된다.
class Secretive private constructor() {} // 이 클래스의 (유일한) 주 생성자는 비공개이다.
// Secretive 클래스 안에는 주 생성자밖에 없고 그 주 생성자는 비공개이므로 외부에서는 Secretive를 인스턴스화할 수 없다. 나중에 동반 객체(companion object)에 대해 설명하면서 동반 객체 안에서 이런 비공개 생성자를 호출하면 좋은 이유에 대해 알아본다.

// 비공개 생성자에 대한 대안
// 유틸리티 함수를 담아두는 역할만을 하는 클래스는 인스턴스화할 필요가 없고, 싱글턴인 클래스는 미리 정한 팩토리 메소드 등의 생성 방법을 통해서만 객체를 생성해야 한다.
// 자바에서는 이런 더 일반적인 요구 사항을 명시할 방법이 없으므로 어쩔 수 없이 private 생성자를 정의해서 클래스를 다른 곳에서 인스턴스화하지 못하게 막는 경우가 생긴다.
// 코틀린은 그런 경우를 언어에서 기본지원한다.
// 정적 유틸리티 대신에 최상위 함수를 쓰거나, 싱글턴을 사용하고 싶으면 객체를 선언하면 된다(object).

// 실제로 대부분의 경우 클래스의 생성자는 아주 단순하다. 그래서 코틀린은 간단한 주 생성자 문법을 제공한다.
// 하지만 다양한 생성자가 필요할 수도 있을 것이다. 다음에는 다양한 생성자를 만드는 여러 방법을 살펴보자.