package step4

// open, final, abstract 변경자: 기본적으로 final

// 자바에서는 final로 명시적으로 상속을 금지하지 않는 모든 클래스를 다른 클래스가 상속할 수 있다. 이렇게 기본적으로 상속이 가능하면 편리한 경우도 많지만 문제가 생기는 경우도 많다.
// 취약한 기반 클래스(fragile base class)라는 문제는 하위 클래스가 기반 클래스에 대해 가졌던 가정이 기반 클래스를 변경함으로써 깨져버린 경우에 생긴다.
// 이 문제를 해결하기 위해 자바 프로그래밍 기법에 대한 책 중 가장 유명한 책인 조슈아 블로크가 쓴 『Effective Java』에서는 "상속을 위한 설계와 문서를 갖추거나, 그럴 수 없다면 상속을 금지하라"라는 조언을 한다.
// 이는 특별히 하위 클래스에서 오버라이드하게 의도된 클래스와 메소드가 아니라면 모두 final로 만들라는 뜻이다. 코틀린도 마찬가지 철학을 따른다.
// 자바의 클래스와 메소드는 기본적으로 상속에 대해 열려있지만 코틀린의 클래스와 메소드는 기본적으로 final이다.
// 어떤 클래스의 상속을 허용하려면 클래스 앞에 open 변경자를 붙여야 한다. 오버라이드를 허용하고 싶은 메소드나 프로퍼티의 앞에도 open 변경자를 붙여야 한다.
open class RichButton: Clickable { // 이 클래스는 열려있다. 다른 클래스가 이 클래스를 상속할 수 있다.
    fun disable() {} // 이 함수는 파이널이다. 하위 클래스가 이 메소드를 오버라이드 할 수 없다.
    open fun animate() {} // 이 함수는 열려있다. 하위 클래스에서 이 메소드를 오버라이드해도 된다.
    override fun click() {} // 이 함수는 (상위 클래스에서 선언된) 열려있는 메소드를 오버라이드 한다. 오버라이드한 메소드는 기본적으로 열려있다.
}

/*
// 오버라이드하는 메소드의 구현을 하위 클래스에서 오버라이드하지 못하게 금지하려면 오버라이드하는 메소드 앞에 final을 명시해야한다.
open class RichButton: Clickable {
    final override fun click() {} // 여기 있는 final은 쓸데 없이 붙은 중복이 아니다. final이 없는 override 메소드나 프로퍼티는 기본적으로 열려있다.
}
*/

// 열린 클래스와 스마트 캐스트
// 클래스의 기본적인 상속 기능 상태를 final로 함으로써 얻을 수 있는 큰 이익은 다양한 경우에 스마트 캐스트가 가능하다는 점이다.
// step2 스마트캐스트에서 말한 것처럼 스마트 캐스트는 타입 검사 뒤에 변경될 수 없는 변수에만 적용 가능하다.
// 클래스의 프로퍼티의 경우 이는 val이면서 커스텀 접근자가 없는 경우에만 스마트 캐스트를 쓸 수 있다는 의미다. 이 요구 사항은 또한 프로퍼티가 final이어야만 한다는 뜻이기도 하다.
// 프로퍼티가 final이 아니라면 그 프로퍼티를 다른 클래스가 사용하면서 커스텀 접근자를 정의함으로써 스마트 캐스트의 요구 사항을 깰 수 있다.
// 프로퍼티는 기본적으로 final이기 때문에 따로 고민할 필요 없이 대부분의 프로퍼티를 스마트캐스트에 활용할 수 있다. 이는 코드를 더 이해하기 쉽게 만든다.


// 추상 클래스
// 자바처럼 코틀린에서도 클래스를 abstract로 선언할 수 있다. abstract로 선언한 추상 클래스는 인스턴스화 할 수 없다.
// 추상 클래스에는 구현이 없는 추상 멤버가 있기 때문에 하위 클래스에서 그 추상 멤버를 오버라이드해야만 하는게 보통이므로 추상 멤버는 항상 열려있다.
// 따라서 추상 멤버 앞에 open 변경자를 명시할 필요가 없다.
abstract class Aniamted { // 이 클래스는 추상 클래스이므로 인스턴스를 만들 수 없다.
    abstract fun animate() // 이 함수는 추상 함수로 구현이 없다. 하위 클래스에서는 이 함수를 반드시 오버라이드해야 한다.
    open fun stopAnimatign() {} // 추상 클래스에 속했더라도 비추상 함수는 기본적으로 파이널이지만 원한다면 open으로 오버라이드를 허용할 수 있다.
    fun animateTwice() {}
}

// 상속 제어자(클래스 멤버에 대해 적용 가능)
// final : 오버라이드 불가능, 클래스의 기본 변경자
// open : 오버라이드 가능, 반드시 open을 명시해야 오버라이드 할 수 있다.
// abstract : 반드시 오버라이드 해야함, 추상 클래스의 멤버에만 붙일 수 있고, 추상 멤버에는 구현이 있으면 안된다.
// override : 상위 클래스나 상위 인스턴스의 멤버를 오버라이드하는 중, 오버라이드 하는 멤버는 기본적으로 열려있다. 하위 클래스의 오버라이드를 금지하려면 final을 명시해야 한다.

// 인터페이스 멤버의 경우 final, open, abstract를 사용하지 않는다.
// 인터페이스의 멤버의 경우 항상 열려 있으며 final로 변경할 수 없다.
// 인터페이스 멤버에게 본문이 없으면 자동으로 추상 멤버가 되지만, 그렇더라도 따로 멤버 선언 앞에 abstract 키워드를 덧붙일 필요가 없다.

// 가시성 변경자 : 기본적으로 공개
// 가시성 변경자(visibility modifier)는 코드 기반에 있는 선언에 대한 클래스 외부 접근을 제어한다.
// 기본적으로 코틀린 가시성 변경자는 자바와 비슷하다. public, protected, private 변경자가 있다. 하지만 코틀린의 기본 가시성은 자바와 달리 아무 변경자도 없는 경우 모두 공개(public)된다.
// 자바의 기본 가시성인 패키지 전용(package-private)은 코틀린에 없다. 코틀린은 패키지를 네임스페이스(namespace)를 관리하기 위한 용도로만 사용한다.
// 패키지 가시성에 대안으로 코틀린에는 internal 이라는 새로운 가시성 변경자를 도입했다(우리말로는 모듈 내부라고 번역한다). internal은 "모듈 내부에서만 볼 수 있음"이라는 뜻이다.
// 모듈(module)은 한 번에 한꺼번에 컴파일되는 코틀린 파일들을 의미한다.
// 모듈 내부 가시성은 여러분의 모듈의 구현에 대해 진정한 캡슐화를 제공한다는 장점이 있다.
// 자바에서는 패키지가 같은 클래스를 선언하기만 하면 어떤 프로젝트의 외부에 있는 코드라도 패키지 내부에 있는 패키지 전용 선언에 쉽게 접근할 수 있다. 그래서 캡슐화가 쉽게 깨진다.
// 다른 차이는 코틀린에서는 최상위 선언에 대해 private 가시성(비공개 가시성)을 허용한다는 점이다. 최상위 선언에는 클래스, 함수, 프로퍼티 등이 포함된다.
// 비공개 가시성인 최상위 선언은 그 선언이 들어있는 파일 내부에서만 사용할 수 있다. 이 또한 하위 시스템의 자세한 구현 사항을 외부에 감추고 싶을 때 유용한 방법이다.
// public(기본 가시성임)
//  - 클래스 멤버 : 모든 곳에서 볼 수 있다.
//  - 최상위 선언 : 모든 곳에서 볼 수 있다.
// internal
//  - 클래스 멤버 : 같은 모듈 안에서만 볼 수 있다.
//  - 최상위 선언 : 같은 모듈 안에서만 볼 수 있다.
// protected
//  - 클래스 멤버 : 하위 클래스 안에서만 볼 수 있다.
//  - 최상위 선언 : 적용 불가능
// private
//  - 클래스 멤버 : 같은 클래스 안에서만 볼 수 있다.
//  - 최상위 선언 : 같은 파일 안에서만 볼 수 있다.
internal open class TalkativeButton: Focusable {
    private fun yell() = println("Hey!")
    protected fun whisper() = println("Let's talk!")
}
/*
// giveSpeech 함수 안의 각 줄은 가시성 규칙을 위반한다.
fun TalkativeButton.giveSpeech() { // 오류:"public" 멤버가 자신의 "internal"수신 타입인 "TalkativeButton"을 노출함
    yell() // 오류: "yell"에 접근할 수 없음. "yell"은 TalkativeButton의 "private" 멤버임.
    whisper() // 오류 : "whisper"에 접근할 수 없음. "whisper"는 TalkativeButton의 "protected" 멤버임.
}

// 코틀린은 public 함수인 giveSpeech 안에서 그보다 가시성이 더 낮은(이 경우 internal)타입인 TalkativeButton을 참조하지 못하게 한다.
// 이는 어떤 클래스의 기반 타입 목록에 들어있는 타입이나 제네릭 클래스의 타입 파라미터에 들어있는 타입의 가시성은 그 클래스 자신의 가시성과 같거나 더 높아야 하고,
// 메소드의 시그니처에 사용된 모든 타입의 가시성은 그 메소드의 가시성과 같거나 더 높아야 한다는 더 일반적인 규칙에 해당한다. 이런 규칙은 어떤 함수를 호출하거나 어떤 클래스를 확장할 때 모든 타입에 접근할 수 있게 보장해준다.
// 여기서 컴파일 오류를 없애려면 giveSpeech 확장 함수의 가시성을 internal로 바꾸거나, TalkativeButton의 가시성은 public으로 바꿔야 한다.

// 자바에서는 같은 패키지 안에서 protected 멤버에 접근할 수 있지만, 코틀린에서는 그렇지 않다는 점에서 자바와 코틀린의 protected가 다르다는 사실에 유의하라.
// 코틀린의 가시성 규칙은 단순하다. protected 멤버는 오직 어떤 클래스나 그 클래스를 상속하나 클래스 안에서만 보인다. 클래스를 확장한 함수는 그 클래스의 private이나 protected 멤버에 접근할 수 없다는 사실을 여기서 한 번 더 짚고 넘어가야겠다.
 */

